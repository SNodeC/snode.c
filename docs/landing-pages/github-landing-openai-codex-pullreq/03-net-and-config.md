# Net Module and Configuration System (`src/net/*`, `src/net/config/*`)

## What this module is

`src/net` specializes core socket abstractions into concrete network families:

- IPv4 (`net/in`)
- IPv6 (`net/in6`)
- Unix domain (`net/un`)
- RFCOMM (`net/rc`)
- L2CAP (`net/l2`)

It also provides the **instance configuration backbone** used by most high-level server/client classes.

## Network specialization pattern

Across families, SNode.C keeps a consistent shape:

1. physical socket layer (`phy/*`)
2. stream or dgram role wrappers
3. config type binding (legacy/tls, server/client)
4. factory helpers (`Server(...)`, `Client(...)` aliases)

This enables near-identical application code while swapping transport families.

## Configuration model: three ways to configure instances

SNode.C exposes configuration in three aligned channels:

## 1) In-code API configuration

- Objects like `ConfigSocketServer` / `ConfigSocketClient` can be configured via lambdas passed to instance constructors.
- Best for libraries or strongly typed deployments where config is generated by code.

## 2) Command-line configuration

- Backed by CLI11 through `ConfigInstance` and `ConfigSection`.
- Sections/options are attached to per-instance CLI subtrees.
- Supports required options, grouping, validators, and type names.

## 3) Config-file persistence

- Options can be marked configurable/non-configurable.
- Persistent options are grouped for config file generation/parsing.
- Enables default instance bootstrapping from config files with CLI override behavior.

## Important config classes

- `ConfigInstance`: instance identity, role (server/client), section registration, disabled flag.
- `ConfigSection`: option and flag creation, requirement tracking, configurable grouping.
- `ConfigConnection`: common read/write block sizes and timeout controls.
- `ConfigPhysicalSocket*`: retry, reconnect, accept/backlog, and socket-level behavior.
- `ConfigLegacy*` / `ConfigTls*`: transport-mode-specific settings, especially TLS paths/options.
- `ConfigAddress*`: local/remote/reverse endpoint structures.

## Instance-centric configuration behavior

The design emphasizes per-instance isolation:

- each named server/client instance has own section namespace,
- required sections can force completeness for specific deployment profiles,
- disabling an instance can happen declaratively in config/CLI.

This is particularly helpful for multi-instance binaries (common in gateways and protocol bridges).

## Functionality summary

- family-specific network wrappers over shared transport runtime
- server/client config symmetry
- unified CLI + config-file + in-code configuration model
- granular socket, timeout, retry, reconnect, TLS, and address controls

## Pros

1. **Strong consistency** across all network families.
2. **Highly operational** (CLI + persistence + code-level override).
3. **Instance naming and scoping** are ideal for multi-tenant/multi-role processes.
4. **Retry/reconnect primitives** are first-class, not ad-hoc.

## Cons / tradeoffs

1. **Large API surface** in config classes can feel dense initially.
2. **Template aliases + config generics** may obscure call stacks during debugging.
3. **Many knobs** means users need guidance to avoid contradictory settings.

## Recommended landing-page emphasis

When presenting SNode.C publicly, call out that configuration is not an afterthought: it is a central design feature that cleanly spans developer control (code), operations control (config file), and runtime override (CLI).
